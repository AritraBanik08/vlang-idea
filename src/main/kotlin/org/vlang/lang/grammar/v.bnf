{
  parserClass='org.vlang.lang.VlangParser'

  implements='org.vlang.lang.psi.VlangCompositeElement'
  extends='org.vlang.lang.psi.impl.VlangCompositeElementImpl'

  elementTypeHolderClass='org.vlang.lang.VlangTypes'
  elementTypeClass='org.vlang.lang.psi.VlangCompositeElementType'
  tokenTypeClass='org.vlang.lang.psi.VlangTokenType'
  psiTreeUtilClass='org.vlang.lang.psi.VlangPsiTreeUtil'

  psiClassPrefix='Vlang'
  psiImplClassSuffix='Impl'
  psiPackage='org.vlang.lang.psi'
  psiImplPackage='org.vlang.lang.psi.impl'
  psiImplUtilClass="org.vlang.lang.psi.impl.VlangPsiImplUtil"
  parserUtilClass="org.vlang.lang.VlangParserUtil"

  tokens=[
    LBRACE               =  '{'
    RBRACE               =  '}'
    LBRACK               =  '['
    HASH_LBRACK          =  '#['
    RBRACK               =  ']'
    RBRACK_EXP           =  ']!'
    LPAREN               =  '('
    RPAREN               =  ')'
    COLON                =  ':'
    SEMICOLON            =  ';'
    COMMA                =  ','
    EQ                   =  '=='
    ASSIGN               =  '='
    NOT_EQ               =  '!='
    NOT                  =  '!'
    QUESTION             =  '?'
    PLUS_PLUS            =  '++'
    PLUS_ASSIGN          =  '+='
    PLUS                 =  '+'
    MINUS_MINUS          =  '--'
    MINUS_ASSIGN         =  '-='
    MINUS                =  '-'
    COND_OR              =  '||'
    BIT_OR_ASSIGN        =  '|='
    BIT_CLEAR_ASSIGN     =  '&^='
    BIT_CLEAR            =  '&^'
    COND_AND             =  '&&'
    BIT_AND_ASSIGN       =  '&='
    BIT_AND              =  '&'
    BIT_OR               =  '|'
    SHIFT_LEFT_ASSIGN    =  '<<='
    SHIFT_LEFT           =  '<<'
    SEND_CHANNEL         =  '<-'
    LESS_OR_EQUAL        =  '<='
    LESS                 =  '<'
    BIT_XOR_ASSIGN       =  '^='
    BIT_XOR              =  '^'
    MUL_ASSIGN           =  '*='
    MUL                  =  '*'
    QUOTIENT_ASSIGN      =  '/='
    QUOTIENT             =  '/'
    REMAINDER_ASSIGN     =  '%='
    REMAINDER            =  '%'
    AT                   =  '@'
    SHIFT_RIGHT_ASSIGN   =  '>>='
    SHIFT_RIGHT          =  '>>'
    GREATER_OR_EQUAL     =  '>='
    GREATER              =  '>'
    VAR_ASSIGN           =  ':='
    TRIPLE_DOT           =  '...'
    DOT                  =  '.'
    RANGE                =  '..'
    TILDA                =  '~'
    SINGLE_QUOTE         =  "'"
    DOUBLE_QUOTE         =  '"'
    BACKTICK             =  '`'
    SEMICOLON_SYNTHETIC  = '<NL>'
    TYPE_                = 'type'
    raw_string           = 'raw_string'
    char                 = 'char'
  ]

  extends("(Or|And|Add|Conversion|Mul|Selector|Conditional|OrBlock)Expr")=BinaryExpr
  extends(".*(Expr|Literal|Lit|OperandName)|TypeInitExpr|MapInitExpr|UnsafeExpression|CompileTimeIfExpression|IfExpression|ArrayCreation|InExpression|NotInExpression|MatchExpression|EnumFetch|MutExpression|SharedExpression|DotExpression|IsExpression|NotIsExpression|AsExpression|UnpackingExpression|ConstexprIdentifierExpression|SqlExpression|GoExpression|LockExpression|IncDecExpression|LiteralValueExpression")=Expression

  implements("(Var|Param|Field|Label|Var|Const|EnumField|GlobalVariable|InterfaceMethod)Definition|(Struct|TypeAlias|Union|Enum|Interface)Declaration|Receiver|Import(Alias)")="org.vlang.lang.psi.VlangNamedElement"
  implements("FunctionLit|(Function|Method)Declaration")="org.vlang.lang.psi.VlangSignatureOwner"
//  implements("InterfaceMethodDeclaration")="org.vlang.lang.psi.VlangNamedSignatureOwner"
  implements("(Function|Method)Declaration")="org.vlang.lang.psi.VlangFunctionOrMethodDeclaration"
//  implements("(Const|Type|Var)Declaration")="org.vlang.lang.psi.GoTopLevelDeclaration"
  implements(".*ReferenceExpression|FieldName")="org.vlang.lang.psi.VlangReferenceExpressionBase"
//  implements("Type")="org.vlang.lang.psi.VlangReferenceExpressionBase"
  implements("(Continue|Break|Goto)Statement")="org.vlang.lang.psi.VlangLabelRefOwnerElement"

  extends("(Function|Method)Declaration")="org.vlang.lang.psi.impl.VlangFunctionOrMethodDeclarationImpl<?>"
  extends("ModuleClause|Type|ImportName")="org.vlang.lang.psi.impl.VlangStubbedElementImpl<?>"
  extends("(Struct|TypeAlias|Union|Enum|Interface)Declaration|(Var|Label|Param|Field|Const|EnumField|GlobalVariable|InterfaceMethod)Definition|Receiver|Import(Alias)")="org.vlang.lang.psi.impl.VlangNamedElementImpl<?>"

  elementTypeFactory("ModuleClause|(Function|Method|Struct|TypeAlias|Union|Enum|Interface)Declaration|.*Type|(Var|Label|Field|Param|Const|EnumField|GlobalVariable|InterfaceMethod)Definition|Receiver|Import(Alias|Name)")='org.vlang.lang.stubs.VlangElementTypeFactory.stubFactory'

  extends(".*Statement")=Statement
  extends(".*Type|TypeList")=Type

  pin('.*List(?:_\d.*)?')=1

  generateTokenAccessors=true
}

// [module <ident>]
// [imports]
//
// [TopLevelDeclarations]
File ::= ModuleClause? ImportList? TopLevelDeclaration*

// General rule for explicit and implicit ';'
private semi ::= '<NL>' | ';' | <<eof>>

// [attr] module <name>
ModuleClause ::= Attributes? module identifier semi {
  pin=2
  methods=[getName]
  stubClass="org.vlang.lang.stubs.VlangModuleClauseStub"
}

// import <part1>
// import <part1>.<part2>
// import <part1>.<part2> { <import list> }
// import <part1>.<part2> as <alias>
ImportList ::= (ImportDeclaration semi)+

// import <spec>
ImportDeclaration ::= import ImportSpec {
  pin=1
  methods=[addImportSpec]
}

// <part1>
// <part1>.<part2>
// <part1> { <ref> }
// <part1> as <alias>
ImportSpec ::= ImportPath (SelectiveImportList | ImportAlias)? {
  methods=[getIdentifier getLastPart getLastPartPsi getName getImportedName]
}

// <part1>
// <part1>.<part2>
ImportPath ::= ImportName ('.' ImportName)* {
  methods=[getQualifiedName getLastPart getLastPartPsi]
}

// just identifier
ImportName ::= identifier {
  stubClass="org.vlang.lang.stubs.VlangImportNameStub"
  methods=[getQualifier getNameIdentifier setName getName getTextOffset getReference resolve]
  implements=["com.intellij.psi.PsiNameIdentifierOwner"; "org.vlang.lang.psi.VlangCompositeElement"]
}

// { <ref>[, <ref2>] }
SelectiveImportList ::= '{' ReferenceExpression (',' ReferenceExpression)* '}' {pin(".*")=2}

// as <ident>
ImportAlias ::= as ImportAliasName {
  pin=1
  stubClass="org.vlang.lang.stubs.VlangImportAliasStub"
  methods=[getName getIdentifier]
}

ImportAliasName ::= identifier {
  methods=[getReference]
}
// end of import rule

////////// TOP LEVEL DECLARATIONS //////////

private TopLevelDeclaration ::= !<<eof>> TopDeclaration semi {pin=1 recoverWhile=TopLevelDeclarationRecover}
private TopDeclaration ::=
    ConstDeclaration
  | FunctionDeclaration
  | MethodDeclaration
  | StructDeclaration
  | EnumDeclaration
  | InterfaceDeclaration
  | UnionDeclaration
  | GlobalVariableDeclaration
  | CompileTimeIfStatement
  | CompileTimeForStatement
  | CIncludeStatement
  | CFlagStatement
  | LanguageInjectionStatement
  | TypeAliasDeclaration

private TopLevelDeclarationRecover ::= !(';' | 'type' | const | fn | pub | BUILTIN_GLOBAL | var | struct | enum | interface | union | import | C_INCLUDE | C_FLAG | FOR_COMPILE_TIME | IF_COMPILE_TIME | LANGUAGE_INJECTION | '[')

////////// TOP LEVEL DECLARATIONS END //////////


////////// STATEMENTS //////////

// Block { }
BlockWithConsume ::= /*<<consumeBlock>> |*/ BlockInner {elementType=Block}
Block ::= BlockInner {methods=[processDeclarations]}
private BlockInner ::= '{' ('}' | (<<withOff Statements "BLOCK?" "PAR">> | (!() Statements)) '}') {pin(".*")=1}
// end of block rule

private Statements ::= StatementWithSemi*

private StatementWithSemi ::= Statement (semi | &'}') { pin=1 recoverWhile=StatementRecover }
Statement ::=
  ConstDeclaration
  | SimpleStatement
  | LockStatement
  | GoStatement
  | ReturnStatement
  | BreakStatement
  | ContinueStatement
  | GotoStatement
  | Block
  | CompileTimeIfStatement
  | IfStatement
  | UnsafeStatement
  | ForStatement
  | CompileTimeForStatement
  | AssertStatement
  | CFlagStatement
  | CIncludeStatement
  | LanguageInjectionStatement
  | TypeAliasDeclaration
  | AsmBlockStatement
  | SqlStatement
  | LabeledStatement
//| SelectStatement
  | DeferStatement {methods=[processDeclarations]}

private StatementRecover ::= !('!' | '?' | '&' | '(' | '*' | '+' | '-' | ';' | '<-' | '^' | 'type' | '{' | '|' | '|=' | '||' | '&&' | '}' | break | case | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | fn | pub | mut | shared | go | goto | hex | identifier | if | int | interface | oct | return | select | string | 'raw_string' | OPEN_QUOTE | char | struct | union | switch | var | unsafe | assert | match | lock | rlock | asm | sql | true | false | FOR_COMPILE_TIME | IF_COMPILE_TIME | ELSE_COMPILE_TIME | BUILTIN_GLOBAL | C_INCLUDE | C_FLAG | LANGUAGE_INJECTION)

// attributes start
// [attr1]
// [attr2]
Attributes ::= Attribute (semi Attribute)* semi? {pin=1}
// [<expr>[, <expr2>]]
Attribute ::= '[' AttributeExpression (';' AttributeExpression)* ']' {pin=1}
// if <ident> or <plain>
AttributeExpression ::= IfAttribute | PlainAttribute
// if <ident>
IfAttribute ::= if '!'? identifier '?'? {pin=1}
// <ident> or 10 or "string" [: <ident> or "string"]
PlainAttribute ::= (identifier | unsafe | default | sql | int | string | StringLiteral) (':' (identifier | StringLiteral))?
// end of attributes

// simple statements
SimpleStatement ::=
  VarDeclaration
  | (LeftHandExprList AssignmentStatement? | SendStatement) {pin(".*")=LeftHandExprList}

// <vars> := <exprs>
VarDeclaration ::= VarDefinitionList ':=' ExpressionList {pin=2}

// <label>: <stmt>
LabeledStatement ::= LabelDefinition Statement? {pin=2}

// = <list>
left AssignmentStatement ::= AssignOp (ExpressionList) {pin=1}
AssignOp ::= '=' | '+=' | '-=' | '|=' | '^=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '&^='

// <- <expr>
left SendStatement ::= '<-' Expression {pin=1 methods=[getSendExpression]}
// end of simple statements

// If-else
// if <condition> { ... } as statement
IfStatement ::= IfExpression
// else { ... }
// else if { ... }
ElseStatement ::= else (IfStatement | Block) {pin=1}

// Compile time if-else
// $if <condition> { ... } as statement
CompileTimeIfStatement ::= CompileTimeIfExpression
// $else { ... }
// $else $if { ... }
CompileElseStatement ::= ELSE_COMPILE_TIME (CompileTimeIfStatement | Block) {pin=1}

// For statement
// [<label>:] for ( ... ) { ... }
ForStatement ::= for <<enterMode "BLOCK?">> (ForOrRangeClause Block | Block | Expression Block) <<exitModeSafe "BLOCK?">> {pin(".*")="for|ForOrRangeClause"}
// <label>:
LabelDefinition ::= identifier ':' {
  pin=2
  stubClass="org.vlang.lang.stubs.VlangLabelDefinitionStub"
}
// for (;;;) or for (<*> in <*>)
private ForOrRangeClause ::= (ForClause | RangeClause)
// [<statement>]; [<expression>]; [<statement>]
ForClause ::= SimpleStatement? ';' Expression? ';' SimpleStatement? {methods=[processDeclarations]}
// in <expression> or <var> in <expression>
RangeClause ::= in Expression | VarDefinitionList in Expression {
  pin(".*")=2
  extends=VarDeclaration
  methods=[getRangeExpression getLeftExpressionsList getRightExpressionsList]
}

// $for (...)  { ... }
CompileTimeForStatement ::= FOR_COMPILE_TIME <<enterMode "BLOCK?">> (ForOrRangeClause Block | Block | Expression Block) <<exitModeSafe "BLOCK?">> {pin(".*")="FOR_COMPILE_TIME|ForOrRangeClause"}

// (r)lock <var> { ... }
LockStatement ::= LockExpression

// go <expt>
GoStatement ::= GoExpression

// return <expr>
// return <expr>, <expr>
ReturnStatement ::= return ExpressionList?

// break [<label>]
BreakStatement ::= break LabelRef?

// continue [<label>]
ContinueStatement ::= continue LabelRef?

// goto <label>
GotoStatement ::= goto LabelRef

// assert <expr>
AssertStatement ::= assert Expression

// unsafe { ... } as statement
UnsafeStatement ::= UnsafeExpression

// defer { ... } rule
DeferStatement ::= defer Block

// <label>:
LabelRef ::= identifier { methods=[getReference getName] }

// TODO
//SelectStatement ::= select '{' CommClause* '}'
//CommClause ::= CommCase ':' Statements? {pin=1}
//CommCase ::= case ( Expression SendStatement | RecvStatement ) | default {pin(".*")="case"}
//RecvStatement ::= ExpressionsOrVariables? Expression {pin=0 extends=VarSpec methods=[getRecvExpression getLeftExpressionsList getRightExpressionsList]}

// #...
// Used for inject other language in code
LanguageInjectionStatement ::= LANGUAGE_INJECTION (semi LANGUAGE_INJECTION)* {pin=1}

// C statements
// #include <string>
CIncludeStatement ::= C_INCLUDE StringLiteral {pin=1}
// #flag ...
CFlagStatement ::= C_FLAG C_FLAG_VALUE {pin=1}
// end of C statements

// asm [volatile] { ... }
AsmBlockStatement ::= asm volatile? identifier AsmBlock {pin=1}
AsmBlock ::= '{' ('}' | (ASM_LINE)* '}') {pin(".*")=1}

SqlStatement ::= SqlExpression

////// DECLARATIONS //////

// struct
StructDeclaration ::= Attributes? SymbolVisibility? StructType {
  stubClass="org.vlang.lang.stubs.VlangStructDeclarationStub"
  methods=[getIdentifier getName]
}

StructType ::= struct identifier GenericArguments? '{' FieldsGroup* '}' {
  pin=1
  implements="org.vlang.lang.psi.VlangFieldListOwner"
  methods=[getFieldList]
}

MemberModifiers ::= MemberModifier* ':' {pin=2}
MemberModifier ::= mut | pub | shared | BUILTIN_GLOBAL

FieldsGroup ::= WithModifiersFieldsGroup | WithoutModifiersFieldsGroup

private WithModifiersFieldsGroup ::= MemberModifiers semi? FieldDeclaration+ {pin=1}
private WithoutModifiersFieldsGroup ::= !MemberModifiers FieldDeclaration+

FieldDeclaration ::= (FieldDefinitionList shared? Type | AnonymousFieldDefinition) Attribute? DefaultFieldValue? Tag? semi
DefaultFieldValue ::= '=' Expression
Tag ::= StringLiteral
private FieldDefinitionList ::= FieldDefinition (',' FieldDefinition)*
FieldDefinition ::= identifier {
  methods=[getQualifier isPublic]
  stubClass="org.vlang.lang.stubs.VlangFieldDefinitionStub"
}

AnonymousFieldDefinition ::= Type {
//  stubClass="org.vlang.lang.stubs.GoAnonymousFieldDefinitionStub"
  methods=[getIdentifier getName getTypeReferenceExpression getGoTypeInner]
}


// interface
InterfaceDeclaration ::= Attributes? SymbolVisibility? InterfaceType {
  stubClass="org.vlang.lang.stubs.VlangInterfaceDeclarationStub"
  methods=[getName getIdentifier getTypeInner]
}

InterfaceType ::= interface identifier GenericArguments? '{' MembersGroup* '}' {
  pin=1
  implements="org.vlang.lang.psi.VlangFieldListOwner"
  methods=[getFieldList getMethodList]
}

MembersGroup ::= WithModifiersMembersGroup | WithoutModifiersMemberGroup

private WithModifiersMembersGroup ::= MemberModifiers semi? InterfaceMember+ {pin=1}
private WithoutModifiersMemberGroup ::= !MemberModifiers InterfaceMember+

private InterfaceMember ::= InterfaceMethodDeclaration | FieldDeclaration | AnonymousInterfaceDefinition

InterfaceMethodDeclaration ::= InterfaceMethodDefinition Attribute? DefaultFieldValue? Tag? semi
InterfaceMethodDefinition ::= identifier Signature {
  implements="org.vlang.lang.psi.VlangSignatureOwner"
  stubClass="org.vlang.lang.stubs.VlangInterfaceMethodDefinitionStub"
  methods=[getTypeInner isPublic]
}

AnonymousInterfaceDefinition ::= Type {
//  stubClass="org.vlang.lang.stubs.GoAnonymousFieldDefinitionStub"
  methods=[getIdentifier getName getTypeReferenceExpression getGoTypeInner]
}


// enum
EnumDeclaration ::= Attributes? SymbolVisibility? EnumType {
  stubClass="org.vlang.lang.stubs.VlangEnumDeclarationStub"
  methods=[getName getIdentifier getTypeInner]
}

EnumType ::= enum identifier GenericArguments? '{' EnumFields? '}' {
  pin=1
  methods=[getFieldList]
}

EnumFields ::= EnumFieldDeclaration (semi EnumFieldDeclaration)* semi?
EnumFieldDeclaration ::= EnumFieldDefinition ('=' Expression)? {pin=1}
EnumFieldDefinition ::= identifier {
  methods=[isPublic]
  stubClass="org.vlang.lang.stubs.VlangEnumFieldDefinitionStub"
}

// union
UnionDeclaration ::= Attributes? SymbolVisibility? UnionType {
  stubClass="org.vlang.lang.stubs.VlangUnionDeclarationStub"
  methods=[getName getIdentifier]
}

UnionType ::= union identifier GenericArguments? '{' FieldsGroup* '}' {
  pin=1
  implements="org.vlang.lang.psi.VlangFieldListOwner"
  methods=[getFieldList]
}

// TODO: split for type alias and sum type?
// [<visibility>] type <ident> = <types>
TypeAliasDeclaration ::= SymbolVisibility? 'type' AliasType {
  pin=2
  stubClass="org.vlang.lang.stubs.VlangTypeAliasDeclarationStub"
  methods=[getIdentifier getName]
}

AliasType ::= Type '=' TypeUnionList {
  pin=2
  methods=[getIdentifier isAlias]
}

// <type> [ | <type2>]...
TypeUnionList ::= Type (semi? '|' Type)* {pin=1}


// const declarations
// [<visibility>] const <name> = <value>
// [<visibility>] const (<list>)
ConstDeclaration ::= SymbolVisibility? const ( ConstDefinition | '(' ConstDefinitions? ')' ) {pin(".*")=2 methods=[addSpec deleteSpec]}
// <spec> [<spec2>]
private ConstDefinitions ::= ConstDefinition (semi ConstDefinition)* semi? {pin=1}
// <list> = <list>
ConstDefinition ::= identifier '=' (<<withOff Expression "BLOCK?">> | (!() Expression)) {
  pin=2
  stubClass="org.vlang.lang.stubs.VlangConstDefinitionStub"
  methods=[deleteDefinition getName getSymbolVisibility]
}

// TODO: when const declaration will support multiple assign
//ConstSpec ::= ConstDefinitionList [ ('=' ExpressionList | TypeDecl '=' ExpressionList) ] {
//  pin(".*")=1
////  stubClass="org.vlang.lang.stubs.GoConstSpecStub"
//  methods=[deleteDefinition]
//}
//private ConstDefinitionList ::= ConstDefinition ( ',' ConstDefinition )*

// end of const


// global variable declarations
// <[attrs]> __global <ident> = <expr>
// <[attrs]> __global (<list>)
GlobalVariableDeclaration ::= Attributes? BUILTIN_GLOBAL ( GlobalVariableDefinition | '(' GlobalVariableDefinitions? ')' ) {pin(".*")=2 methods=[addSpec deleteSpec]}
// <spec> [<spec2>]
private GlobalVariableDefinitions ::= GlobalVariableDefinition (semi GlobalVariableDefinition)* semi? {pin=1}
// <def> = <expr>
// <def> <type>
GlobalVariableDefinition ::= identifier (VarModifiers Type | GlobalVariableValue) {
  pin=1
  stubClass="org.vlang.lang.stubs.VlangGlobalVariableDefinitionStub"
  methods=[deleteDefinition getName getSymbolVisibility]
}

private GlobalVariableValue ::= '=' (<<withOff Expression "BLOCK?">> | (!() Expression)) { pin=1 }

VarModifiers ::= (mut | shared)*

SymbolVisibility ::= pub | BUILTIN_GLOBAL

GenericArguments ::= '<' TypeListNoPin '>' {pin=3}

FunctionDeclaration ::= Attributes? SymbolVisibility? fn identifier GenericArguments? Signature BlockWithConsume? {
  pin=4
  stubClass="org.vlang.lang.stubs.VlangFunctionDeclarationStub"
  methods=[getName getTypeInner isDefinition]
}

MethodDeclaration ::= Attributes? SymbolVisibility? fn '(' Receiver ')' MethodName GenericArguments? Signature BlockWithConsume? {
  pin=7
  stubClass="org.vlang.lang.stubs.VlangMethodDeclarationStub"
  methods=[getReceiverType getTypeInner getIdentifier]
}
// <ident> or <ops> for overload
MethodName ::= identifier | AddOp | MulOp | RelOp

// [mut|shared] <ident> <type>
Receiver ::= VarModifiers? identifier ReceiverTail {
  pin=3
  methods=[getTypeInner getName]
  stubClass="org.vlang.lang.stubs.VlangReceiverStub"
}
private ReceiverTail ::= Type ','?

////// DECLARATIONS END //////


////////// STATEMENTS END //////////


////////// EXPRESSIONS //////////

Expression ::=
    OrExpr
  | AndExpr
  | ConditionalExpr
  | AddExpr
  | MulExpr
  | UnaryExpr
  | SendExpr
  | RangeExpr
  | MatchExpression
  | IfExpression
  | CompileTimeIfExpression
  | InExpression
  | NotInExpression
  | IsExpression
  | NotIsExpression
  | AsExpression
  | MaxGroup
  | EnumFetch
  | MutExpression
  | SharedExpression
  | ConstexprIdentifierExpression
  | SqlExpression
  | GoExpression
  | LockExpression
  | IncDecExpression
  | UnpackingExpression
  | ParenthesesExpr {methods=[getType] implements="org.vlang.lang.psi.VlangTypeOwner"}
// end of expression rule

// (r)lock <var> { ... }
LockExpression ::= (lock | rlock) <<enterMode "BLOCK?">> ExpressionList Block <<exitModeSafe "BLOCK?">>  {pin=1}

// go <expr>
GoExpression ::= go Expression

// { ... }
MapInitExpr ::= (<<isLastNotIs "BLOCK?">> | <<isLastIs "PAR">>) & <<prevIsNotType>> '{' KeyValues? '}' {pin=4}
KeyValues ::= KeyValue ((semi | ',') KeyValue)* (semi | ',')? {pin=1}
// <key> : <value>
KeyValue ::= Expression ':' Expression {pin=2}

// <type> {...}
LiteralValueExpression ::= Type GenericArguments? ((<<isLastNotIs "BLOCK?">> | <<isLastIs "PAR">> | <<prevIsType>>) & <<prevIsNotFunType>>) '{' ElementList? '}' {pin=4}
private ElementList ::= ElementInner ((',' | semi) ElementInner?)*
private ElementInner ::= Element | (!() Element) {recoverWhile=ElementInnerRecover}
private ElementInnerRecover ::= !('}' | ',' | semi | ')')
Element ::= First [':' Value]  {pin(".*")=1}
private First ::= Key | <<keyOrValueExpression>>
Key ::= (FieldName &':') | !() Expression // nullability hack for key without reference inside
FieldName ::= ReferenceExpression { methods=[getIdentifier getQualifier] }
Value ::= Expression | LiteralValueExpression

// end of type init

private MaxGroup ::=
    DotExpression
  | Literal
  | FunctionLit
//| CompositeLit

// fn (...) {...}
FunctionLit ::= fn CaptureList? Signature Block {pin=1 methods=[processDeclarations]}
// [<var1>, <var2>, ...]
CaptureList ::= '[' (Capture | ',' Capture)* ']' {pin=3}
// [mut] <ident>
Capture ::= VarDefinition {pin=1}

////// TYPES //////

Type ::= (TypeLit | TypeName) GenericArguments? {
  stubClass="org.vlang.lang.stubs.VlangTypeStub"
  methods=[getIdentifier getUnderlyingType resolveType]
}
//  | ParType {
//  stubClass="org.vlang.lang.stubs.GoTypeStub"
//  methods=[getUnderlyingType shouldGoDeeper]
//  }
//ParType ::= '(' Type ')' {methods=[getActualType]}

private TypeName ::= TypeReferenceExpression QualifiedTypeReferenceExpression*

left QualifiedTypeReferenceExpression ::= '.' identifier {elementType=TypeReferenceExpression}
TypeReferenceExpression ::= identifier { methods=[getReference getQualifier resolve getType] }

private TypeLit ::=
    ArrayOrSliceType
  | TupleType
  | PointerType
  | NullableType
  | NotNullableType
  | FunctionType
  | MapType
  | ChannelType
  | StructType
  | InterfaceType

// [<expr>]<type>
ArrayOrSliceType ::= '[' Expression? ']' Type {pin=3}

TupleType ::= '(' TypeListNoPin ')' {pin=3}

// &<type>
// &&<type>
// &&&<type>
PointerType ::= ('&' | '&&')+ Type {pin=1}
// !<type>
// bare !
NotNullableType ::= '!' Type? {pin=1}
// ?<type>
// bare ?
NullableType ::= '?' Type? {pin=1}
// fn (...) <type>
// fn (...) (<type1>, <type2>, ...)
FunctionType ::= fn Signature {
  pin=1
  implements="org.vlang.lang.psi.VlangSignatureOwner"
}

// signature
// (...) ...
Signature ::= Parameters Result? {pin=1 /*stubClass="org.vlang.lang.stubs.GoSignatureStub"*/}
Result ::= Type {
  methods=[isVoid]
//  stubClass="org.vlang.lang.stubs.GoResultStub"
}
Parameters ::= '(' [ (ParameterList ','?| TypeListNoPin) ] ')' {
  pin=1
  methods=[getParametersList getParametersListWithTypes]
//  stubClass="org.vlang.lang.stubs.GoParametersStub"
}
private ParameterList ::= ParameterDeclaration (',' (ParameterDeclaration | &')'))* {pin(".*")=1}
ParameterDeclaration ::= (ParamDefinitionListNoPin? '...'? Type) | Type { // todo: use left rule
//  stubClass="org.vlang.lang.stubs.GoParameterDeclarationStub"
  methods = [isVariadic]
}
private ParamDefinitionListNoPin ::= ParamDefinition &(!('.' | ')')) (',' ParamDefinition)* // todo
ParamDefinition ::= VarModifiers? identifier {
  stubClass="org.vlang.lang.stubs.VlangParamDefinitionStub"
  methods = [isVariadic getName]
}
TypeListNoPin ::= Type (',' Type)* ','?
// end of signature

// map[<type>]<type>
MapType ::= 'map' '[' Type ']' Type {
  pin=2
  methods = [
    keyType="Type[0]"
    valueType="Type[1]"
  ]
}

// chan <type>
ChannelType ::= chan Type? {pin=1}

////// TYPES END //////


LeftHandExprList ::= ExpressionList

private ExpressionList ::= ExpressionWithRecover (',' (ExpressionWithRecover | &')'))* {pin(".*")=1}
private ExpressionWithRecover ::= Expression !':' {recoverWhile=ExpressionListRecover}
private ExpressionListRecover ::= !('!' | '?' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | ')' | '*' | '*=' | '+'  | '++' | '+=' | ',' | '-' | '--' | '-=' | '...' | '/' | '/=' | ':' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '<NL>' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | ']' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | chan | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | fn | go | goto | hex | identifier | if | int | interface | oct | return | select | string | 'raw_string' | OPEN_QUOTE | char | struct | enum | union | switch | var | unsafe | assert | match | asm | sql | true | false | nil )

private VarDefinitionList ::= VarDefinition (',' VarDefinition)*
VarDefinition ::= VarModifiers? identifier {
  pin=2
  methods=[getTypeInner getName getReference getValue getSymbolVisibility]
  stubClass="org.vlang.lang.stubs.VlangVarDefinitionStub"
}

// <ident>[.<ident>]*
DotExpression ::= DotPrimaryExpr RightHandExprs {extends=Expression}

private DotPrimaryExpr ::=
    LiteralValueExpression
  | ReferenceExpression
  | Literal
  | FunctionLit
  | ArrayCreation
  | ParenthesesExpr
  | UnsafeExpression
  | MapInitExpr

// just <ident> with ref
ReferenceExpression ::= identifier { methods=[getReference getQualifier resolve getReadWriteAccess] extends=Expression}
left QualifiedReferenceExpression ::= semi? '.' identifier {elementType=ReferenceExpression}

private RightHandExprs ::= RightHandExpr*

private RightHandExpr ::=
    CallExpr
  | IndexOrSliceExpr
  | QualifiedReferenceExpression
  | OrBlockExpr
  | ErrorPropagationExpression
  | ForceNoErrorPropagationExpression

// <expr>[<<generics>>](...)
left CallExpr ::= GenericArguments? ArgumentList {
  methods=[getParameters]
}

// <expr>[<expr>]
// <expr>#[<exr>]
// <expr>[0..10]
// <expr>[..10]
// <expr>[0..]
left IndexOrSliceExpr ::= ('[' | HASH_LBRACK) (SliceExprBody | IndexExprBody) '..'? ']' !identifier
private IndexExprBody ::= Expression SliceExprBodyInner?
private inner SliceExprBodyInner ::= SliceExprBody
private SliceExprBody ::= &'..' '..' Expression

// <expr> or { ... }
left OrBlockExpr ::= or Block

// math and logical expressions
OrExpr ::= Expression semi? '||' Expression
AndExpr ::= Expression semi? '&&' Expression
SendExpr ::= Expression '<-' Expression
UnaryExpr ::=  UnaryOp Expression {methods=[getOperator]}
ConditionalExpr ::= Expression RelOp Expression
AddExpr ::= Expression AddOp Expression
MulExpr ::= Expression MulOp Expression

private RelOp ::= '==' | '!=' | '<' | '<=' | '>' !'>' | '>='
private AddOp ::= '+' | '-' | '|' | '^'
private MulOp ::= '*' | '/' | '%' | '<<' | <<gtGt>> | '&' | '&^'
private UnaryOp ::= '+' | '-' | '!' | '^' | '~' | '*' | '&' | '&&' | '<-'

fake BinaryExpr ::= Expression+ {
  methods=[left="Expression[0]" right="Expression[1]" getOperator]
}
// end of math and logical expressions

ParenthesesExpr ::= '(' <<enterMode "PAR">> Expression <<exitModeSafe "PAR">>')' {pin=1}

// <expr>++/--
IncDecExpression ::= Expression ('++' | '--') {pin=1}

// @<ident>
ConstexprIdentifierExpression ::= '@' identifier {pin=2}

// <expr>?
ErrorPropagationExpression ::= '?' {pin=1}

// <expr>!
ForceNoErrorPropagationExpression ::= '!' {pin=1}

// ...<expr>
UnpackingExpression ::= '...' Expression {pin=1}

// .<ident>
EnumFetch ::= '.' ReferenceExpression {pin=2}

// <expr>..<expr>
// <expr>...<expr> (inclusive)
RangeExpr ::= Expression ('..' | '...') !']' Expression {pin=2}

// mut <expr>
MutExpression ::= mut Expression

// shared <expr>
SharedExpression ::= shared Expression

// [<list>]
ArrayCreation ::= '[' <<enterMode "PAR">> ArrayCreationList? semi? (<<exitModeSafe "PAR">> ']' '!'?) {pin=1}
// <expr1>, <expr2>, ..., <exprN>
ArrayCreationList ::= ExpressionWithRecover (','? ExpressionWithRecover)* ','? {pin(".*")=0}

// ([<arg1>, <arg2>[...], ...])
ArgumentList ::= '(' <<enterMode "PAR">> ElementList? '...'? ','? <<exitModeSafe "PAR">> ')' {pin=1}

// match <expr> { ... }
MatchExpression ::= match <<enterMode "BLOCK?">> Expression '{' MatchArms '}' <<exitAllModeSafe "BLOCK?">> {pin=1}
// <expr>[, <expr2>] { ... }
// else { ... }
MatchArms ::= (MatchArm | MatchElseArmClause)*
// <expr>[, <expr2>] { ... }
MatchArm ::= <<enterMode "BLOCK?">> MatchExpressionList <<exitModeSafe "BLOCK?">> Block semi {pin=2}
// <expr>[, <expr2>]
private MatchExpressionList ::= MatchArmExpression (',' MatchArmExpression)* {pin=0}
// <expr> or <type>
private MatchArmExpression ::= <<typeOrExpression>>
// else { ... }
MatchElseArmClause ::= else Block semi {pin=1}

// <expr> in <expr>
InExpression ::= Expression in Expression {pin=2}
// <expr> !in <expr>
NotInExpression ::= Expression NOT_IN Expression {pin=2}

// <expr> is <expr>
IsExpression ::= Expression is Type {pin=2}
// <expr> !is <expr>
NotIsExpression ::= Expression NOT_IS Type {pin=2}

// <expr> as <expr>
AsExpression ::= Expression as Type {pin=2}

// unsafe { ... }
UnsafeExpression ::= unsafe Block {pin=1}

// if <condition> { ... }
IfExpression ::= if Condition semi? Block (semi? ElseStatement)? {pin=1}

//  $if <condition> { ... }
CompileTimeIfExpression ::= IF_COMPILE_TIME Condition Block CompileElseStatement? {pin=1}
private Condition ::= <<enterMode "BLOCK?">> (VarDeclaration | Expression) <<exitModeSafe "BLOCK?">>

// sql <ident> { ... }
SqlExpression ::= sql identifier SqlBlock {pin=1}
SqlBlock ::= '{' ('}' | (SQL_LINE)* '}') {pin(".*")=1}

////////// EXPRESSIONS END //////////


////// LITERALS //////

// literals line 0 or 10.5 and other
Literal ::=
    int
  | float
  | floati
  | decimali
  | hex
  | oct
  | bin
  | true
  | false
  | StringLiteral
  | char
  | nil {
  methods=[isNumeric]
}

// just different strings
StringLiteral ::= string | 'raw_string' | StringTemplate {
//  implements = "com.intellij.psi.PsiLanguageInjectionHost"
  methods = [isValidHost updateText createLiteralTextEscaper getDecodedText getContents]
}

StringTemplate ::= OPEN_QUOTE StringTemplatePart* CLOSING_QUOTE {pin=1}

private StringTemplatePart ::=
    LITERAL_STRING_TEMPLATE_ENTRY
  | LITERAL_STRING_TEMPLATE_ESCAPE_ENTRY
  | LongStringTemplateEntry
  | ShortStringTemplateEntry
  | SHORT_TEMPLATE_ENTRY_START

LongStringTemplateEntry ::= LONG_TEMPLATE_ENTRY_START Expression FormatSpecifier? LONG_TEMPLATE_ENTRY_END {pin=1}

FormatSpecifier ::= ':' FormatSpecifierExpression
FormatSpecifierExpression ::= (FormatSpecifierLeftAlignFlag | FormatSpecifierRightAlignFlag)? FormatSpecifierWidthAndPrecision? FormatSpecifierLetter?
FormatSpecifierLeftAlignFlag ::= '-'
FormatSpecifierRightAlignFlag ::= '+'
FormatSpecifierWidthAndPrecision ::= int | float
FormatSpecifierLetter ::= identifier

ShortStringTemplateEntry ::= SHORT_TEMPLATE_ENTRY_START Expression {pin=2}

////// LITERALS END //////
