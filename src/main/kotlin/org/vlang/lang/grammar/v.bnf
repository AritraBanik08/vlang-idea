{
  parserClass='org.vlang.lang.VlangParser'

  implements='org.vlang.lang.psi.VlangCompositeElement'
  extends='org.vlang.lang.psi.impl.VlangCompositeElementImpl'

  elementTypeHolderClass='org.vlang.lang.VlangTypes'
  elementTypeClass='org.vlang.lang.psi.VlangCompositeElementType'
  tokenTypeClass='org.vlang.lang.psi.VlangTokenType'
  psiTreeUtilClass='org.vlang.lang.psi.VlangPsiTreeUtil'

  psiClassPrefix='Vlang'
  psiImplClassSuffix='Impl'
  psiPackage='org.vlang.lang.psi'
  psiImplPackage='org.vlang.lang.psi.impl'
  psiImplUtilClass="org.vlang.lang.psi.impl.VlangPsiImplUtil"
  parserUtilClass="org.vlang.lang.VlangParserUtil"

  tokens=[
    LBRACE               =  '{'
    RBRACE               =  '}'
    LBRACK               =  '['
    HASH_LBRACK          =  '#['
    RBRACK               =  ']'
    RBRACK_EXP           =  ']!'
    LPAREN               =  '('
    RPAREN               =  ')'
    COLON                =  ':'
    SEMICOLON            =  ';'
    COMMA                =  ','
    EQ                   =  '=='
    ASSIGN               =  '='
    NOT_EQ               =  '!='
    NOT                  =  '!'
    QUESTION             =  '?'
    PLUS_PLUS            =  '++'
    PLUS_ASSIGN          =  '+='
    PLUS                 =  '+'
    MINUS_MINUS          =  '--'
    MINUS_ASSIGN         =  '-='
    MINUS                =  '-'
    COND_OR              =  '||'
    BIT_OR_ASSIGN        =  '|='
    BIT_CLEAR_ASSIGN     =  '&^='
    BIT_CLEAR            =  '&^'
    COND_AND             =  '&&'
    BIT_AND_ASSIGN       =  '&='
    BIT_AND              =  '&'
    BIT_OR               =  '|'
    SHIFT_LEFT_ASSIGN    =  '<<='
    SHIFT_LEFT           =  '<<'
    SEND_CHANNEL         =  '<-'
    LESS_OR_EQUAL        =  '<='
    LESS                 =  '<'
    BIT_XOR_ASSIGN       =  '^='
    BIT_XOR              =  '^'
    MUL_ASSIGN           =  '*='
    MUL                  =  '*'
    QUOTIENT_ASSIGN      =  '/='
    QUOTIENT             =  '/'
    REMAINDER_ASSIGN     =  '%='
    REMAINDER            =  '%'
    AT                   =  '@'
    SHIFT_RIGHT_ASSIGN   =  '>>='
    SHIFT_RIGHT          =  '>>'
    GREATER_OR_EQUAL     =  '>='
    GREATER              =  '>'
    VAR_ASSIGN           =  ':='
    TRIPLE_DOT           =  '...'
    DOT                  =  '.'
    RANGE                =  '..'
    SEMICOLON_SYNTHETIC  = '<NL>'
    TYPE_                = 'type'
    raw_string           = 'raw_string'
    char                 = 'char'
  ]

  extends("(Or|And|Add|Conversion|Mul|Selector|Conditional|OrBlock)Expr")=BinaryExpr
  extends(".*(Expr|Literal|Lit|OperandName)|StructInitialization|UnsafeExpression|CompileTimeIfExpression|IfExpression|ArrayCreation|InExpression|NotInExpression|MatchExpression|EnumFetch|MutExpression|DotExpression|IsExpression|NotIsExpression|AsExpression|UnpackingExpression|ErrorPropagationExpression|ConstexprIdentifierExpression")=Expression

  implements("(Type|Import)Spec|(Var|Const|Param|Field|Label)Definition|(Struct)Declaration|Receiver")="org.vlang.lang.psi.VlangNamedElement"
//  implements("FunctionLit")="org.vlang.lang.psi.GoSignatureOwner"
//  implements("MethodSpec")="org.vlang.lang.psi.GoNamedSignatureOwner"
  implements("(Function|Method)Declaration")="org.vlang.lang.psi.VlangFunctionOrMethodDeclaration"
//  implements("(Const|Type|Var)Declaration")="org.vlang.lang.psi.GoTopLevelDeclaration"
  implements(".*ReferenceExpression|FieldName")="org.vlang.lang.psi.VlangReferenceExpressionBase"
  implements("TypeDecl")="org.vlang.lang.psi.VlangReferenceExpressionBase"

  extends("ImportSpec|ParamDefinition|Receiver|(Var|Const|Field|Label)Definition")="org.vlang.lang.psi.impl.VlangSimpleNamedElementImpl"

  extends("(Function|Method)Declaration")="org.vlang.lang.psi.impl.VlangFunctionOrMethodDeclarationImpl<?>"
  extends("ModuleClause")="org.vlang.lang.psi.impl.VlangStubbedElementImpl<?>"
  extends("StructDeclaration")="org.vlang.lang.psi.impl.VlangNamedElementImpl<?>"

  elementTypeFactory("ModuleClause|(Function|Method|Struct)Declaration")='org.vlang.lang.stubs.VlangElementTypeFactory.stubFactory'

//  pin(".*Statement")=1
  extends(".*Statement")=Statement
  extends(".*Type|TypeList")=TypeDecl

  pin('.*List(?:_\d.*)?')=1

  generateTokenAccessors=true
}

File ::= ModuleClause? ImportList? TopLevelDeclaration*
ImportList ::= (ImportDeclaration semi)+ {
  methods=[addImport]
}
private semi ::= '<NL>' | ';' | <<eof>>

ErrorPropagation ::= '?'

ModuleClause ::= Attributes? module identifier semi {pin=2
  methods=[getName]
  stubClass="org.vlang.lang.stubs.VlangModuleClauseStub"
}

ImportDeclaration ::= import ImportSpec {
  pin(".*")=1
  methods=[addImportSpec]
}

ImportSpec ::= ImportString ('.' ImportString)* (SelectiveImportList | as ImportAlias)? {
//  stubClass="org.vlang.lang.stubs.GoImportSpecStub"
  methods=[getIdentifier getAlias getLocalPackageName shouldGoDeeper isForSideEffects isDot getPath getName isCImport]
}
private ImportString ::= identifier {methods=[getReferences resolve getPath getPathTextRange]}

SelectiveImportList ::= '{' ReferenceExpression (',' ReferenceExpression)* '}' {pin(".*")=2}

ImportAlias ::= identifier {pin(".*")=2}

TypeDecl ::= TypeLit
  | TypeName {
  methods=[getIdentifier]
}
//  | ParType {
//  stubClass="org.vlang.lang.stubs.GoTypeStub"
//  methods=[getUnderlyingType shouldGoDeeper]
//  }

//ParType ::= '(' Type ')' {methods=[getActualType]}
private TypeName ::= TypeReferenceExpression (QualifiedTypeReferenceExpression)*
TypeReferenceExpression ::= identifier { methods=[getReference getQualifier resolve resolveType] }
left QualifiedTypeReferenceExpression ::= '.' identifier {elementType=TypeReferenceExpression}

private TypeLit ::=
    ArrayOrSliceType
  | StructType
  | PointerType
  | NullableType
  | FunctionType
//  | InterfaceType
  | MapType
//  | ChannelType

ArrayOrSliceType ::= '[' ('...'|Expression?) ']' TypeDecl {pin=1}

EnumDeclaration ::= Attributes? SymbolVisibility? enum identifier '{' EnumFields '}' {pin=3}
EnumFields ::= EnumFieldDeclaration (semi EnumFieldDeclaration)* semi?
EnumFieldDeclaration ::= identifier ('=' Expression)? {pin=1}

StructDeclaration ::= Attributes? SymbolVisibility? StructType {
  stubClass="org.vlang.lang.stubs.VlangStructDeclarationStub"
  methods=[getIdentifier getName]
}

StructType ::= struct identifier? '{' Fields? '}' {pin=1}

MemberModifiers ::= MemberModifier (MemberModifier)* ':' {pin=1}
MemberModifier ::= mut | pub | BUILTIN_GLOBAL

DefaultFieldValue ::= '=' Expression
private Fields ::= MemberModifiers? FieldDeclaration? (semi Fields)* semi? {pin=1}
FieldDeclaration ::= (FieldDefinitionList TypeDecl | AnonymousFieldDefinition) DefaultFieldValue? Attribute? Tag?
Tag ::= StringLiteral
private FieldDefinitionList ::= FieldName (',' FieldName)*
FieldName ::= identifier {
//  stubClass="org.vlang.lang.stubs.GoFieldDefinitionStub"
}

AnonymousFieldDefinition ::= TypeDecl {
//  stubClass="org.vlang.lang.stubs.GoAnonymousFieldDefinitionStub"
  methods=[getIdentifier getName getTypeReferenceExpression getGoTypeInner]
}

StructInitialization ::= TypeDecl '{' ( '}' | FieldInitialization '}') {pin=3}
FieldInitialization ::= FieldInitializationKeyValueList | FieldInitializationValueList
FieldInitializationKeyValueList ::= ((FieldInitializationKeyValue | UnpackingExpression) semi)+ semi?
private FieldInitializationKeyValue ::= FieldInitializationKey ':' Expression {pin=2}
FieldInitializationKey ::= Expression
FieldInitializationValueList ::= FieldInitializationValue (',' FieldInitializationValue)* ','?
// see return if a > b { a } else { b }
private FieldInitializationValue ::= Expression {pin=1}


PointerType ::= '&' TypeDecl {pin=1}
NullableType ::= '?' TypeDecl? {pin=1}

FunctionType ::= fn Signature {pin=1 /*implements="org.vlang.lang.psi.GoSignatureOwner"*/}

Signature ::= Parameters Result? {
  pin=1
//  stubClass="org.vlang.lang.stubs.GoSignatureStub"
}
Result ::= '(' TypeListNoPin ')' | TypeDecl | Parameters { // todo: reorder and pin (
  methods=[isVoid]
//  stubClass="org.vlang.lang.stubs.GoResultStub"
}
Parameters ::= '(' [ (ParameterList ','?| TypeListNoPin) ] ')' {
  pin=1
//  stubClass="org.vlang.lang.stubs.GoParametersStub"
}
private ParameterList ::= ParameterDeclaration (',' (ParameterDeclaration | &')'))* {pin(".*")=1}
ParameterDeclaration ::= ParamDefinitionListNoPin? '...'? TypeDecl | TypeDecl { // todo: use left rule
//  stubClass="org.vlang.lang.stubs.GoParameterDeclarationStub"
  methods = [isVariadic]
}
private ParamDefinitionListNoPin ::= ParamDefinition &(!('.' | ')')) (',' ParamDefinition)* // todo
ParamDefinition ::= SymbolMutability identifier {
//  stubClass="org.vlang.lang.stubs.GoParamDefinitionStub"
  methods = [isVariadic]
}

InterfaceDeclaration ::= Attributes? SymbolVisibility? InterfaceType

InterfaceType ::= interface identifier? '{' InterfaceMembers? '}' {pin=1}

private InterfaceMembers ::= MemberModifiers? (InterfaceFieldDeclaration | InterfaceMethodDeclaration | AnonymousInterfaceDefinition)? (semi InterfaceMembers)* semi? {pin=1}
InterfaceFieldDeclaration ::= (FieldDefinitionList TypeDecl) Attribute? Tag?
InterfaceMethodDeclaration ::= identifier Signature Attribute? Tag?

AnonymousInterfaceDefinition ::= TypeDecl {
//  stubClass="org.vlang.lang.stubs.GoAnonymousFieldDefinitionStub"
  methods=[getIdentifier getName getTypeReferenceExpression getGoTypeInner]
}

MapType ::= 'map' '[' TypeDecl ']' TypeDecl {
  pin=1
  methods = [
    keyType="Type[0]"
    valueType="Type[1]"
  ]
}

//ChannelType ::= ChanTypePrefix Type {pin=1}
//private ChanTypePrefix ::= chan '<-'? | '<-' chan {pin(".*")=1}
//
BlockWithConsume ::= /*<<consumeBlock>> |*/ BlockInner {elementType=Block}
Block ::= BlockInner {methods=[processDeclarations]}
private BlockInner ::= '{' ('}' | Statements '}') {pin(".*")=1}
private Statements ::= StatementWithSemi*

private StatementWithSemi ::= Statement (semi | &'}') { pin=1 recoverWhile=StatementRecover }
Statement ::=
  ConstDeclaration
//  | TypeDeclaration
//  VarDeclaration
//  | LabeledStatement
  | SimpleStatement
  | GoStatement
  | ReturnStatement
  | BreakStatement
  | ContinueStatement
//  | GotoStatement
//  | FallthroughStatement
  | Block
  | CompileTimeIfStatement
  | IfStatement
  | UnsafeStatement
//  | SwitchStatement
//  | SelectStatement
  | ForStatement
  | CompileTimeForStatement
  | AssertStatement
  | CFlagStatement
  | CIncludeStatement
  | LanguageInjectionStatement
  | TypeStatement
  | DeferStatement {methods=[processDeclarations]}


private StatementRecover ::= !('!' | '?' | '&' | '(' | '*' | '+' | '-' | ';' | '<-' | '^' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | fn | pub | mut | go | goto | hex | identifier | if | int | interface | oct | return | select | string | raw_string | char | struct | switch | var | unsafe | assert | match | FOR_COMPILE_TIME | IF_COMPILE_TIME | ELSE_COMPILE_TIME | BUILTIN_GLOBAL | C_INCLUDE | C_FLAG | LANGUAGE_INJECTION)

SimpleStatement ::=
  ShortVarDeclaration
  | IncDecStatement
  | (LeftHandExprList AssignmentStatement? /*| SendStatement*/) {pin(".*")=LeftHandExprList}

TypeStatement ::= SymbolVisibility 'type' identifier '=' TypeUnionList {pin=2}
TypeUnionList ::= TypeDecl ('|' TypeDecl)* {pin=1}

LanguageInjectionStatement ::= LANGUAGE_INJECTION {pin=1}

CIncludeStatement ::= C_INCLUDE StringLiteral {pin=1}
CFlagStatement ::= C_FLAG C_FLAG_VALUE {pin=1}

private TopLevelDeclaration ::= !<<eof>> TopDeclaration semi {pin=1 recoverWhile=TopLevelDeclarationRecover}
private TopDeclaration ::=
  ConstDeclaration
//  | TypeDeclaration
//  | VarDeclaration
  | FunctionDeclaration
  | MethodDeclaration
  | StructDeclaration
  | EnumDeclaration
  | InterfaceDeclaration
  | GlobalVariableDeclaration
  | CompileTimeIfStatement
  | CompileTimeForStatement
  | CIncludeStatement
  | CFlagStatement
  | LanguageInjectionStatement
  | TypeStatement

private TopLevelDeclarationRecover ::= !(';' | 'type' | const | fn | pub | BUILTIN_GLOBAL | var | struct | enum | interface | import | C_INCLUDE | C_FLAG | FOR_COMPILE_TIME | IF_COMPILE_TIME | LANGUAGE_INJECTION | '[')

ConstDeclaration ::= SymbolVisibility const ( ConstSpec | '(' ConstSpecs? ')' ) {pin(".*")=2 methods=[addSpec deleteSpec]}
private ConstSpecs ::= ConstSpec (semi ConstSpec)* semi? {pin=1}
ConstSpec ::= ConstDefinitionList [ ('=' ExpressionList | TypeDecl '=' ExpressionList) ] {
  pin(".*")=1
//  stubClass="org.vlang.lang.stubs.GoConstSpecStub"
  methods=[deleteDefinition]
}
private ConstDefinitionList ::= ConstDefinition ( ',' ConstDefinition )*
ConstDefinition ::= identifier {
//  stubClass="org.vlang.lang.stubs.GoConstDefinitionStub"
  methods=[getGoTypeInner getValue]
}


GlobalVariableDeclaration ::= Attributes? BUILTIN_GLOBAL identifier '=' Expression {pin=3}

LeftHandExprList ::= ExpressionList
private ExpressionArgList ::= NamedExpressionArgList | SimpleExpressionArgList

private SimpleExpressionArgList ::= ExpressionOrTypeWithRecover (',' (ExpressionOrTypeWithRecover | &')'))* {pin(".*")=2}
private ExpressionOrTypeWithRecover ::= Expression {recoverWhile=ExpressionListRecover}

private NamedExpressionArgList ::= NamedArgumentExpr ((semi | ',') (NamedArgumentExpr | &')'))* {pin(".*")=1}
private NamedArgumentExpr ::= identifier ':' (Expression | UnpackingExpression) {pin=2}

private ExpressionList ::= ExpressionWithRecover (',' (ExpressionWithRecover | &')'))* {pin(".*")=1}
private ExpressionWithRecover ::= Expression {recoverWhile=ExpressionListRecover}
private ExpressionListRecover ::= !('!' | '?' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '...' | '/' | '/=' | ':' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '<NL>' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | ']' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | chan | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | fn | go | goto | hex | identifier | if | int | interface | oct | return | select | string | raw_string | char | struct | enum | switch | var | unsafe | assert | match)

//TypeDeclaration ::= 'type' ( TypeSpec | '(' TypeSpecs? ')' ) {pin(".*")=1}
//private TypeSpecs ::= TypeSpec (semi TypeSpec)* semi? {pin=1}
//TypeSpec ::= SpecType {
//  methods=[getGoTypeInner getMethods shouldGoDeeper identifier="SpecType/identifier"]
//  stubClass="org.vlang.lang.stubs.GoTypeSpecStub"
//}
//SpecType ::= identifier Type {pin=1 stubClass="org.vlang.lang.stubs.GoTypeStub" extends="org.vlang.lang.psi.impl.GoTypeImpl" implements=Type}
//
//VarDeclaration ::= var ( VarSpec | '(' VarSpecs? ')' ) {pin(".*")=1 methods=[addSpec deleteSpec]}
//private VarSpecs ::= VarSpec (semi VarSpec)* semi? {pin=1}
//VarSpec ::= VarDefinitionList ( Type [ '=' ExpressionList ] | '=' ExpressionList ) {
//  pin(".*")=1
//  methods=[processDeclarations deleteDefinition getRightExpressionsList]
////  stubClass="org.vlang.lang.stubs.GoVarSpecStub"
//}
private VarDefinitionList ::= VarDefinition ( ',' VarDefinition )*
VarDefinition ::= SymbolMutability identifier {
  pin=2
  methods=[getGoTypeInner getReference getValue]
//  stubClass="org.vlang.lang.stubs.GoVarDefinitionStub"
}

ShortVarDeclaration ::= VarDefinitionList ':=' ExpressionList {pin=2}

SymbolMutability ::= mut?

SymbolVisibility ::= (pub | BUILTIN_GLOBAL)?

FunctionDeclaration ::= Attributes? SymbolVisibility fn identifier Signature BlockWithConsume? {
  pin=4
  stubClass="org.vlang.lang.stubs.VlangFunctionDeclarationStub"
  methods=[getName]
}

MethodDeclaration ::= Attributes? SymbolVisibility fn Receiver MethodName Signature BlockWithConsume? {
  pin=5
  stubClass="org.vlang.lang.stubs.VlangMethodDeclarationStub"
  methods=[getReceiverType getIdentifier]
}
MethodName ::= identifier | AddOp | MulOp | RelOp

Receiver ::= '(' (SymbolMutability identifier ReceiverTail | ReceiverTail) ')' {
  methods=[getGoTypeInner]
  pin=1
//  stubClass="org.vlang.lang.stubs.GoReceiverStub"
}
private ReceiverTail ::= TypeDecl ','?

Attributes ::= Attribute (semi Attribute)* semi? {pin=1}
Attribute ::= '[' AttributeExpression (';' AttributeExpression)* ']' {pin=1}
AttributeExpression ::= IfAttribute | PlainAttribute

IfAttribute ::= if identifier {pin=1}
PlainAttribute ::= (identifier | unsafe | int | string | StringLiteral) (':' (identifier | StringLiteral))?

Literal ::=
    int
  | float
  | floati
  | decimali
  | hex
  | oct
  | bin
  | StringLiteral
  | char

StringLiteral ::= string | raw_string | char {
//  implements = "com.intellij.psi.PsiLanguageInjectionHost"
  methods = [isValidHost updateText createLiteralTextEscaper getDecodedText]
}

DotExpression ::= Expression '.' MethodOrField {pin=1}

private MethodOrField ::= MethodCall | FieldLookup
FieldLookup ::= identifier
MethodCall ::= identifier ArgumentList {pin=2}

ReferenceExpression ::= identifier { methods=[getReference getQualifier resolve getReadWriteAccess] extends=Expression}

//
//CompositeLit ::= (LiteralTypeExprInner LiteralValue | TypeName LiteralValue) {pin(".*")="LiteralTypeExprInner"} // the brackets are valuable
//private LiteralTypeExprInner ::= StructType | ArrayOrSliceType | MapType
//
//LiteralTypeExpr ::= LiteralTypeExprInner | TypeName
//
//LiteralValue ::= (<<isModeOff "BLOCK?">> | <<isModeOn "PAR">> | <<prevIsType>>) '{' ElementList? '}' {pin=2}
//private ElementList  ::= E ( ',' E? )*
//private E ::= <<withOn "PAR" Element>> | (!() Element) {recoverWhile=E_recover}
//private E_recover ::= !('}'|',')
//Element ::= First [':' Value]  {pin(".*")=1}
//private First ::= Key | <<keyOrValueExpression>>
//Key ::= (FieldName &':') | !() Expression // nullability hack for key without reference inside
//FieldName ::= identifier { methods=[getReference getQualifier resolve] }
//Value ::= Expression | LiteralValue

FunctionLit ::= fn Signature Block {pin=1 methods=[processDeclarations]}

Expression ::=
    OrBlockExpr
  | OrExpr
  | AndExpr
  | ConditionalExpr
  | AddExpr
  | MulExpr
  | UnaryExpr
//  | ConversionExpr
  | RangeExpr
  | StructInitialization
  | UnsafeExpression
  | MatchExpression
  | IfExpression
  | CompileTimeIfExpression
  | ArrayCreation
  | InExpression
  | NotInExpression
  | IsExpression
  | NotIsExpression
  | AsExpression
  | MaxGroup
  | EnumFetch
  | MutExpression
  | DotExpression
  | ErrorPropagationExpression
  | ConstexprIdentifierExpression
  | ParenthesesExpr {methods=[getGoType] /*implements="org.vlang.lang.psi.GoTypeOwner"*/}

fake BinaryExpr ::= Expression+ {
  methods=[left="Expression[0]" right="Expression[1]" getOperator]
}

ConstexprIdentifierExpression ::= '@' identifier {pin=2}
ErrorPropagationExpression ::= Expression '?' {pin=1}
UnpackingExpression ::= '...' Expression {pin=1}
EnumFetch ::= '.' identifier {pin=2}

OrBlockExpr ::= Expression or Block
OrExpr ::= Expression '||' Expression
AndExpr ::= Expression '&&' Expression
UnaryExpr ::=  UnaryOp Expression {methods=[getOperator]}
ConditionalExpr ::= Expression RelOp Expression
AddExpr ::= Expression AddOp Expression
MulExpr ::= Expression MulOp Expression
ParenthesesExpr ::= '(' /*<<enterMode "PAR">>*/ Expression /*<<exitModeSafe "PAR">>*/')' {pin=1}

RangeExpr ::= Expression ('..' | '...') !']' Expression {pin=2}

MutExpression ::= mut Expression

//BuiltinCallExpr ::= ReferenceExpression <<isBuiltin>> BuiltinArgumentList {pin=2}
//BuiltinArgumentList ::= '(' [ BuiltinArgsInner ','? ] ')' {pin=1 extends=ArgumentList}
//private BuiltinArgsInner ::= Type [ ',' BuiltinArgsTail ] | BuiltinArgsTail
//private BuiltinArgsTail ::= ExpressionList '...'?
//
private MaxGroup ::=
//    CompositeLit
  ReferenceExpression
//  | BuiltinCallExpr
  | CallExpr
//  | TypeAssertionExpr
//  | SelectorExpr
  | IndexOrSliceExpr
  | Literal
  | FunctionLit
//
private RelOp ::= '==' | '!=' | '<' | '<=' | '>' | '>='
private AddOp ::= '+' | '-' | '|' | '^'
private MulOp ::= '*' | '/' | '%' | '<<' | '>>' | '&' | '&^'
private UnaryOp ::= '+' | '-' | '!' | '^' | '*' | '&' | '&&' | '<-'

ArrayCreation ::= '[' ArrayCreationList? (']' '!'?) {pin=1}
ArrayCreationList ::= ExpressionWithRecover (',' (ExpressionWithRecover | &']'))* {pin(".*")=1}

//SelectorExpr ::= Expression '.' !('(' 'type') Expression
IndexOrSliceExpr ::= Expression ('[' | HASH_LBRACK) (SliceExprBody | IndexExprBody) '..'? ']' {pin=2 methods = [getExpression getIndices]}
private IndexExprBody ::= Expression SliceExprBodyInner?
private inner SliceExprBodyInner ::= SliceExprBody
private SliceExprBody ::= &'..' '..' Expression
//TypeAssertionExpr ::= Expression '.' '(' &(!'type') Type ')'
CallExpr ::= Expression ArgumentList
ArgumentList ::= '(' [ ExpressionArgList '...'? ','? ] ')' {pin=1}
//ConversionExpr ::= &ConversionPredicate Type ConversionTail
//private ConversionPredicate ::= ConversionStart | '(' ConversionStart
//private ConversionTail ::= '(' Expression ','? ')' {pin=1}
//private ConversionStart ::= '*' | '<-' | '[' | chan | fn | interface | map | struct
//
//LabeledStatement ::= LabelDefinition ':' Statement? {pin=2}
//LabelDefinition ::= identifier {
//  stubClass="org.vlang.lang.stubs.GoLabelDefinitionStub" // todo: remove when you'll have some spare time
//}
//left SendStatement ::= '<-' Expression {pin=1 methods=[getSendExpression]}
left AssignmentStatement ::= assign_op ExpressionList {pin=1}
IncDecStatement ::= Expression ('++' | '--') {pin=2}
assign_op ::= '=' | '+=' | '-=' | '|=' | '^=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '&^='

private MatchExpressionList ::= Expression (',' Expression)* {pin(".*")=1}
MatchExpression ::= match Expression '{' MatchArms '}' {pin=1}
MatchArms ::= (MatchArm | MatchElseArmClause)*
MatchArm ::= MatchExpressionList Block semi {pin=2}
MatchElseArmClause ::= else Block semi {pin=1}

InExpression ::= Expression in Expression {pin=2}
NotInExpression ::= Expression NOT_IN Expression {pin=2}

IsExpression ::= Expression is Expression {pin=2}
NotIsExpression ::= Expression NOT_IS Expression {pin=2}

AsExpression ::= Expression as Expression {pin=2}

IfExpression ::= if Condition Block ElseStatement? {pin=1}
IfStatement ::= IfExpression
ElseStatement ::= else (IfStatement | Block) {pin=1}

CompileTimeIfExpression ::= IF_COMPILE_TIME Condition Block CompileElseStatement? {pin=1}
CompileTimeIfStatement ::= CompileTimeIfExpression
CompileElseStatement ::= ELSE_COMPILE_TIME (CompileTimeIfStatement | Block) {pin=1}

UnsafeExpression ::= unsafe Block {pin=1}
UnsafeStatement ::= UnsafeExpression

//SwitchStatement ::= SwitchStart (TypeSwitchStatement | ExprSwitchStatement)
//SwitchStart ::= switch
//left ExprSwitchStatement ::= Condition '{' ExprCaseClause* '}' {pin=2 extends=SwitchStatement}
//
private Condition ::= SimpleStatementOpt Expression? ErrorPropagation?
private SimpleStatementOpt ::= [SimpleStatement ';'?] // todo: remove ?

//ExprCaseClause ::= !'}' ExprSwitchCase ':' Statements? {pin=1 implements="org.vlang.lang.psi.GoCaseClause"}
//private ExprSwitchCase ::= case ExpressionList | default {pin(".*")=1}
//left TypeSwitchStatement ::= (TypeSwitchGuard | SimpleStatement ';'? TypeSwitchGuard) '{' ( TypeCaseClause )* '}' {pin=1 extends=SwitchStatement}
//TypeSwitchGuard ::= [ VarDefinition ':=' ] Expression '.' TypeGuard
//TypeGuard ::= '(' 'type' ')' {pin=2}
//TypeCaseClause ::= !'}' TypeSwitchCase ':' Statements? {pin=1 implements="org.vlang.lang.psi.GoCaseClause"}
//private TypeSwitchCase ::= case TypeList | default {pin(".*")=1}
TypeList ::= TypeDecl ( ',' TypeDecl )* ','?
TypeListNoPin ::= TypeDecl ( ',' TypeDecl )* ','? {elementType=TypeList}

ForStatement ::= for (ForOrRangeClause Block | Block | Expression Block) {pin(".*")="for|ForOrRangeClause"}
private ForOrRangeClause ::= (ForClause | RangeClause)
ForClause ::= SimpleStatement? ';' Expression? ';' SimpleStatement? {methods=[processDeclarations]}
RangeClause ::= in Expression | VarDefinitionList in Expression {pin(".*")=2 extends=ShortVarDeclaration methods=[getRangeExpression getLeftExpressionsList getRightExpressionsList]}

CompileTimeForStatement ::= FOR_COMPILE_TIME (ForOrRangeClause Block | Block | Expression Block) {pin=1}

GoStatement ::= go Expression
//SelectStatement ::= select '{' CommClause* '}'
//CommClause ::= CommCase ':' Statements? {pin=1}
//CommCase ::= case ( Expression SendStatement | RecvStatement ) | default {pin(".*")="case"}
//RecvStatement ::= ExpressionsOrVariables? Expression {pin=0 extends=VarSpec methods=[getRecvExpression getLeftExpressionsList getRightExpressionsList]}
ReturnStatement ::= return ExpressionList?
LabelRef ::= identifier { methods=[getReference] }
BreakStatement ::= break LabelRef?
ContinueStatement ::= continue LabelRef?
//GotoStatement ::= goto LabelRef
//FallthroughStatement ::= fallthrough
AssertStatement ::= assert Expression
DeferStatement ::= defer Block